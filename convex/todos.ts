/**
 * Convex CRUD Operations Demo - Todos
 *
 * This file demonstrates the core concepts of Convex:
 *
 * 1. QUERIES vs MUTATIONS
 *    - `query`: Read-only functions that fetch data. They're automatically reactive -
 *      when the underlying data changes, any component using the query re-renders.
 *    - `mutation`: Functions that modify data (create, update, delete). They run as
 *      transactions, ensuring data consistency.
 *
 * 2. THE `ctx` OBJECT
 *    - `ctx.db`: Database access for reading/writing documents
 *    - Convex handles all the connection pooling, caching, and optimization for you
 *
 * 3. VALIDATORS (`v`)
 *    - Type-safe argument validation that runs at runtime
 *    - `v.string()`, `v.boolean()`, `v.id('tableName')` etc.
 *    - These generate TypeScript types automatically!
 */

import { v } from 'convex/values'
import { mutation, query } from './_generated/server'

/**
 * LIST ALL TODOS
 *
 * A `query` function that fetches all todos, sorted by newest first.
 *
 * Key concepts:
 * - Queries are READ-ONLY - they can't modify data
 * - They're REACTIVE - UI automatically updates when data changes
 * - `ctx.db.query('tableName')` starts a query builder
 * - `.order('desc')` sorts by `_creationTime` descending (newest first)
 * - `.collect()` executes the query and returns all results as an array
 */
export const list = query({
  args: {},
  handler: async (ctx) => {
    // Fetch all todos, newest first
    const todos = await ctx.db.query('todos').order('desc').collect()
    return todos
  },
})

/**
 * CREATE A NEW TODO
 *
 * A `mutation` function that inserts a new todo document.
 *
 * Key concepts:
 * - Mutations CAN modify data (insert, update, delete)
 * - They run as TRANSACTIONS - all changes succeed or none do
 * - `args` defines the required input with validators
 * - `ctx.db.insert('tableName', document)` creates a new document
 * - Returns the new document's `_id` (auto-generated by Convex)
 */
export const create = mutation({
  args: {
    title: v.string(), // The todo text - validated at runtime
  },
  handler: async (ctx, args) => {
    // Insert a new todo with completed=false by default
    const todoId = await ctx.db.insert('todos', {
      title: args.title,
      completed: false,
    })
    return todoId
  },
})

/**
 * TOGGLE TODO COMPLETION
 *
 * A `mutation` that flips the `completed` status of a todo.
 *
 * Key concepts:
 * - `v.id('todos')` validates that the argument is a valid ID for the todos table
 * - `ctx.db.get(id)` fetches a single document by its `_id`
 * - `ctx.db.patch(id, fields)` updates specific fields (partial update)
 * - Unlike `.replace()`, `.patch()` only modifies the fields you specify
 */
export const toggleComplete = mutation({
  args: {
    id: v.id('todos'), // Type-safe ID validation - must be a valid todos document ID
  },
  handler: async (ctx, args) => {
    // Fetch the current todo
    const todo = await ctx.db.get(args.id)
    if (!todo) {
      throw new Error('Todo not found')
    }

    // Patch only the `completed` field, flipping its value
    await ctx.db.patch(args.id, {
      completed: !todo.completed,
    })
  },
})

/**
 * DELETE A TODO
 *
 * A `mutation` that permanently removes a todo document.
 *
 * Key concepts:
 * - `ctx.db.delete(id)` removes the document with that ID
 * - Deletion is permanent - there's no soft delete built-in
 * - The function name is `remove` (not `delete`) because `delete` is a JS reserved word
 */
export const remove = mutation({
  args: {
    id: v.id('todos'), // Must be a valid todos document ID
  },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id)
  },
})
